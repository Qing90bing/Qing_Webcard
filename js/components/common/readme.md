# 通用组件 (Common Components)

## 目录概述

`common` 目录存放的是全局通用的工具型组件。

这些组件不与任何特定的业务功能（如天气、时钟）绑定，而是为整个应用提供基础的、可复用的交互功能。将它们放在这里，意味着项目的任何部分都可能需要用到它们。

---

## 文件详解

### `escape-handler.js` - 全局 'Escape' 键处理器

#### 职责

这个模块的功能非常专一：它为整个页面设置了一个统一的 `Escape` (Esc) 按键的事件监听器。

当用户按下 `Esc` 键时，它会按照一个预设的优先级顺序，智能地关闭当前最上层的窗口或视图。例如，如果开发者设置和常规设置两个模态框都（通过某种方式）同时打开了，它会确保总是先关闭最顶层的那个。

这种集中式的处理方式避免了在多个不同的组件中重复编写“监听Esc键并关闭自己”的逻辑，使得代码更整洁，行为更可预测。

### `tooltip.js` - 全局工具提示

#### 职责

这个模块实现了一个全局的、由JavaScript驱动的工具提示（Tooltip）功能。

它的工作方式是自动寻找HTML中任何带有 `data-tooltip` 属性的元素。当用户的鼠标悬停在这些元素上时，它会动态地创建一个提示框，并计算其最佳位置来显示 `data-tooltip` 属性中的文本内容。当鼠标移开时，提示框会自动消失。

---

## > 给初学者的小贴士：什么是“事件委托” (Event Delegation)？

在 `tooltip.js` 中，我们使用了一种非常高效和常见的JavaScript技巧，叫做“事件委托”。

**问题场景：** 页面上可能有几十个甚至上百个需要工具提示的元素。最笨的办法是为每一个元素都用 `addEventListener` 绑定一个 `mouseover` 事件。这样做会创建大量的事件监听器，当元素非常多时，会占用不必要的内存，影响性能。

**解决方案：** 事件委托。利用了DOM事件的“冒泡”机制。

我们不给每个元素单独绑定事件，而是只给它们共同的父元素（在这个项目中，是 `document.body`）绑定**一个**事件监听器。

当你在某个按钮上移动鼠标时，`mouseover` 事件会发生，然后这个事件会像水中的气泡一样，从这个按钮开始，向上“冒泡”到它的父元素，再到父元素的父元素，最终到达 `document.body`。

我们在 `body` 上设置的那个唯一的监听器就会捕捉到这个事件。然后，它会检查这个事件最初是从哪个元素 (`event.target`) 来的。如果这个来源元素是我们关心的（即带有 `data-tooltip` 属性的元素），我们就执行显示提示框的逻辑。

**代码片段示例:**
```javascript
// 只在 body 上添加一个监听器
document.body.addEventListener('mouseover', (e) => {
    // e.target 是鼠标当前悬停的那个元素
    // .closest() 会检查 e.target 自身以及它的所有父元素，
    // 看是否有匹配 '[data-tooltip]' 选择器的
    const target = e.target.closest('[data-tooltip]');

    // 如果找到了，就说明应该显示提示框
    if (target) {
        // ...执行显示提示框的代码...
        showTooltip(target);
    }
});
```

这种方法只用了一个事件监听器就管理了页面上所有的工具提示，非常高效，是处理大量相似元素事件的理想模式。
