# 节假日倒计时与列表模块 (Holiday Countdown & List)

## 目录概述

本模块负责所有与“节假日”相关的功能。它是一个复合模块，主要包含两大部分：

1.  **节日倒计时卡片**: 在主界面显示的一个小卡片，用于动态计算并展示距离下一个重要节假日还有多少天。
2.  **全年假日列表**: 一个功能完整的、可交互的全屏卡片视图，用户可以查看任意年份的所有公历/农历节日和二十四节气，并能方便地切换年份。

---

## 文件详解

### `calendar.js` - 日历核心算法库

#### 职责

这是一个强大且独立的**工具库**，它不包含任何UI逻辑，专门负责所有与中国日历相关的复杂计算。

1.  **农历转换 (Lunar Conversion)**:
    -   本文件的核心是 `Dianaday` 函数，它基于一个为1900-2050年预先计算好的、高度压缩的 `lunarInfo` 数据集，能够将任意一个公历日期，精确地转换为其对应的农历日期（包括天干地支、年份、月份、日子、是否闰月等）。

2.  **节日数据 (Holiday Data)**:
    -   文件内包含了多个静态数组，如 `sFtv` (公历固定节日) 和 `lFtv` (农历固定节日)，作为计算的依据。

3.  **节气计算 (Solar Term Calculation)**:
    -   能够根据天文数据，计算出一年中的二十四节气的准确公历日期。

4.  **聚合函数 (Aggregation Function)**:
    -   向外暴露的主要公共接口是 `getAllHolidaysForYear(year)` 函数。这个函数是本模块的“集大成者”，它接收一个年份作为输入，然后调用内部的各种计算函数，最终返回一个**按日期排好序的、包含该年份所有事件**（公历节日、农历节日、节气、母亲节等特殊日期）的数组。`holiday-display.js` 就是通过调用这个函数来获取其需要展示的数据。

### `holiday-display.js` - 假日UI显示与交互

#### 职责

如果说 `calendar.js` 是“大脑”，那么 `holiday-display.js` 就是“面孔和双手”。它负责将 `calendar.js` 计算出的数据，以美观、可交互的方式呈现给用户。

1.  **倒计时卡片 (Countdown Card)**:
    -   包含 `updateCountdown` 函数，它会调用 `calendar.js` 来找出“下一个”即将到来的节日，然后计算出天数差异，并将其友好地显示在主界面的倒计时卡片上（例如，显示为“还有 5 天”、“明天”或“今天”）。这个函数会通过定时器定期运行，以保持数据的更新。

2.  **假日列表视图 (Holiday List View)**:
    -   管理着那个可以全屏显示的全年假日列表。其功能非常丰富：
        -   **渲染**: 从 `calendar.js` 获取到全年事件列表后，它会按月份对这些事件进行分组，并动态生成整个列表的HTML。
        -   **交互**: 实现了完整的年份切换功能，包括“上一年/下一年”按钮，以及一个可以直接点击修改的年份显示。
        -   **智能滚动**: 当用户打开列表时，它会自动地、平滑地将列表滚动到下一个即将到来的节日的位置，方便用户查看。
        -   **UI状态管理**: 使用了 `IntersectionObserver` 这种高效的方式，来判断“返回今日”这个悬浮按钮是否应该显示。（详见下文技术细节）

---

## 技术实现细节

### 紧凑的农历数据 (Compact Lunar Data)

在 `calendar.js` 中，你会看到一个名为 `lunarInfo` 的、由很多十六进制数组成的数组。这并非随机数，而是一种经典的、用于在极小空间内存储大量信息的**位掩码 (Bitmask)** 技术。

数组中的每一个数字，都高效地编码了一整年农历的所有关键信息：
-   低12位 (`0x0FFF`)：每一位代表一个农历月份，`1` 代表大月（30天），`0` 代表小月（29天）。
-   高4位 (`0xF000`)：代表这一年闰月的月份，`0` 代表不闰月。

在那个JavaScript需要考虑每一字节大小的网页发展的早期，这种按位存储信息的方式是一种非常重要的优化技巧。

### 高性能的可见性检测 (High-Performance Visibility Detection)

在 `holiday-display.js` 中，有一个需求：当用户向上滚动列表，使得“下一个节日”的位置已经看不见时，才显示“返回今日”的按钮。

**传统的低效做法**是监听列表的 `scroll` 事件。但 `scroll` 事件在滚动过程中会以极高的频率被触发，在每一次触发时都去调用 `getBoundingClientRect()` 来计算元素位置，会消耗大量性能，可能导致页面滚动时出现卡顿。

**现代的高效解决方案**: 本模块使用了 `IntersectionObserver` (交叉观察器) API。
-   我们不再自己去监听滚动，而是告诉浏览器：“请帮我**观察**这个‘下一个节日’元素”。
-   浏览器会用它内部最高效的方式去处理。只有当这个元素与视口（滚动容器）的交叉状态**发生改变**时（例如，从“完全可见”变为“部分可见”，或从“可见”变为“不可见”），浏览器才会回调我们提供的JavaScript函数。

这种方式将繁重的计算任务交给了浏览器底层去优化，我们的代码只在最关键的时刻（可见性发生变化时）执行一次，从而极大地提升了性能，保证了滚动的流畅。
