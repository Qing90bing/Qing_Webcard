# 今日人品 (Luck Game) 功能模块

## 目录概述

这是一个复合型的趣味功能模块，它在主界面的“时间胶囊”卡片上实现了一个多阶段的“今日人品”小游戏。

它主要由三部分构成：
1.  **每日运气盲盒**: 用户每天有一次机会点击卡片，获取一个随机的“人品值”和对应的趣味评语。
2.  **疯狂点击游戏**: 在当日人品值揭晓后，卡片会转变为一个点击计数器，用户可以通过快速连续点击来触发一系列的彩蛋信息。
3.  **粒子动画系统**: 一个内置的可配置粒子系统，用于在特定事件（如开出高分、疯狂点击时）触发庆祝式的粒子爆发效果。

---

## 文件详解

### `luck-game.js` - 游戏核心逻辑与粒子系统

#### 职责

这是本功能最核心的文件，包含了绝大部分的逻辑和数据。

1.  **每日运气**: 负责每日仅生成一次人品值的逻辑。它会将生成的日期、分值和评语保-存在 `localStorage` 中，以防止用户在同一天内重复获取。它还包含一个大型的 `luckTiers` 对象，用于根据不同的人品分数区间，匹配不同的趣味文案。
2.  **点击游戏**: 实现“疯狂点击”阶段的逻辑，包括追踪点击次数、在达到特定里程碑（如100次、500次）时显示不同的吐槽信息。
3.  **粒子系统**: 内置了一个名为 `particleEffects` 的独立、可配置的粒子动画系统。这个系统可以在指定的DOM元素周围触发粒子爆发效果，并且支持多种形状（圆形、方形、心形）乃至自定义的SVG图标，为游戏提供了丰富的视觉反馈。
4.  **状态机**: 通过一个 `luckGameState` 变量，管理着整个卡片复杂的交互状态（例如：`initial` 初始状态, `result_shown` 已显示结果, `prompt_1` 第一次挑衅, `counting` 正在计数等），确保了各阶段之间的流畅转换。

### `luck-game-ui.js` - 游戏UI交互 (彩蛋)

#### 职责

这个文件的作用非常专一：它为开发者或测试者提供了一个隐藏的“彩蛋”功能。

它会监听“时间胶囊”卡片标题上的图标的点击事件。当用户快速连续点击该图标5次时，它会调用从 `luck-game.js` 中导入的 `resetLuckGame()` 函数。

这使得测试人员可以方便地重置整个“今日人品”游戏的状态，以反复测试“每日首次游玩”的体验，而无需手动去清理浏览器的 `localStorage`。

---

## 技术实现细节

### 加权随机数 (Weighted Random Numbers)

为了让“今日人品”游戏的结果更有趣、更符合直觉，人品值的生成并没有使用简单的 `Math.random()`，而是采用了一种加权算法来近似一个**正态分布（钟形曲线）**。

**代码片段 (`luck-game.js`):**
```javascript
function generateWeightedLuck() {
    // 使用贝茨分布（n个均匀分布变量之和）来近似正态分布。n=4提供了一个不错的钟形曲线。
    let x = 0;
    for (let i = 0; i < 4; i++) {
        x += Math.random();
    }
    x = x / 4; // x现在位于[0, 1]，峰值在0.5
    // ...后续还有一些偏移和缩放操作...
    return finalValue;
}
```
**这样做的好处是：**
-   大部分时候，用户会得到一个中间范围的分数（如40-70分）。
-   极高分（如90+）和极低分（如10分以下）出现的概率会显著降低。
这比完全线性的随机数感觉更“真实”，也让开出高分或低分时更具戏剧性。

### 数据驱动的粒子系统

`luck-game.js` 中的 `particleEffects` 对象是一个很好的“数据驱动设计”的例子。它的配置被集中在一个 `PARTICLE_CONFIG` 对象中。

这意味着，如果一个开发者想要添加一种全新的粒子形状（例如，一个自定义的SVG图标），他**不需要去修改任何动画逻辑代码**。他只需要在 `PARTICLE_CONFIG.svgShapes` 这个数组中，添加一个新的配置对象即可。

**代码片段 (`luck-game.js`):**
```javascript
const PARTICLE_CONFIG = {
    // ...其他配置...
    svgShapes: [
        {
            svg: '<svg>...</svg>', // 清理过的SVG代码字符串
            randomColor: true,    // 是否应用随机颜色
            size: 60              // 自定义尺寸
        },
        // 要添加新粒子，只需在这里加一个新对象
        {
            svg: '<svg>...</svg>',
            randomColor: false,
        }
    ],
    // ...
};
```
这种设计极大地提高了系统的**可扩展性**和**可维护性**。非动画专业的开发者也能轻松地通过修改数据来改变视觉效果，而不用担心破坏复杂的动画渲染循环。
